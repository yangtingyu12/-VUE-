{"ast":null,"code":"// 目标: 铺设热搜关键字\n// 1. 搜索框van-search组件, 关键词标签和样式\n// 2. 找接口, api/Search.js里定义获取搜索关键词的请求方法\n// 3. 引入到当前页面, 调用接口拿到数据循环铺设页面\n// 4. 点击关键词把值赋予给van-search的v-model变量\n// 目标: 铺设搜索结果\n// 1. 找到搜索结果的接口 - api/Search.js定义请求方法\n// 2. 再定义methods里getListFn方法(获取数据)\n// 3. 在点击事件方法里调用getListFn方法拿到搜索结果数据\n// 4. 铺设页面(首页van-cell标签复制过来)\n// 5. 把数据保存到data后, 循环van-cell使用即可(切换歌手字段)\n// 6. 互斥显示搜索结果和热搜关键词\n// 目标: 搜索框-显示结果\n// 1. @input给van-search绑定事件\n// 2. @input事件中, 获取搜索结果保存 resultList中\n// 3. 判断如果搜索关键字为空(.length === 0), 数组清空, 阻止网络请求执行(提前return)\n// 目标: 加载更多\n// 1. 集成list组件-定义相关的变量(搞懂变量的作用) -监测触底事件\n// 2. 一旦触底, 自动执行onload方法\n// 3. 对page++, 给后台传递offset偏移量参数-请求下一页的数据\n// 4. 把当前数据和下一页新来的数据拼接起来用在当前 页面的数组里\n// (切记) - 加载更多数据后,一定要把loading改成false, 保证下一次还能触发onload方法\nimport { hotSearchAPI, searchResultListAPI } from \"@/pi\";\nimport SongItem from \"@/components/SongItem\";\nexport default {\n  data() {\n    return {\n      value: \"\",\n      // 搜索关键词\n      hotArr: [],\n      // 热搜关键字\n      resultList: [],\n      // 搜索结果\n      loading: false,\n      // 加载中 (状态) - 只有为false, 才能触底后自动触发onload方法\n      finished: false,\n      // 未加载全部 (如果设置为true, 底部就不会再次执行onload, 代表全部加载完成)\n      page: 1,\n      // 当前搜索结果的页码\n      timer: null // 输入框-防抖定时器\n\n    };\n  },\n\n  async created() {\n    const res = await hotSearchAPI();\n    console.log(res);\n    this.hotArr = res.data.result.hots;\n  },\n\n  methods: {\n    async getListFn() {\n      return await searchResultListAPI({\n        keywords: this.value,\n        limit: 20,\n        offset: (this.page - 1) * 20 // 固定公式\n\n      }); // 把搜索结果return出去\n      // (难点):\n      // async修饰的函数 -> 默认返回一个全新Promise对象\n      // 这个Promise对象的结果就是async函数内return的值\n      // 拿到getListFn的返回值用await提取结果\n    },\n\n    async fn(val) {\n      // 点击热搜关键词\n      this.page = 1; // 点击重新获取第一页数据\n\n      this.finished = false; // 点击新关键词-可能有新的数据\n\n      this.value = val; // 选中的关键词显示到搜索框\n\n      const res = await this.getListFn();\n      console.log(res);\n      this.resultList = res.data.result.songs;\n      this.loading = false; // 本次数据加载完毕-才能让list加载更多\n    },\n\n    async inputFn() {\n      // 目标: 输入框改变-逻辑代码-慢点执行\n      // 解决: 防抖\n      // 概念: 计时n秒, 最后执行一次, 如果再次触发, 重新计时\n      // 效果: 用户在n秒内不触发这个事件了, 才会开始执行逻辑代码\n      if (this.timer) clearTimeout(this.timer);\n      this.timer = setTimeout(async () => {\n        this.page = 1; // 点击重新获取第一页数据\n\n        this.finished = false; // 输入框关键字改变-可能有新数据(不一定加载完成了)\n        // 输入框值改变\n\n        if (this.value.length === 0) {\n          // 搜索关键词如果没有, 就把搜索结果清空阻止网络请求发送(提前return)\n          this.resultList = [];\n          return;\n        }\n\n        const res = await this.getListFn();\n        console.log(res); // 如果搜索结果响应数据没有songs字段-无数据\n\n        if (res.data.result.songs === undefined) {\n          this.resultList = [];\n          return;\n        }\n\n        this.resultList = res.data.result.songs;\n        this.loading = false;\n      }, 900);\n    },\n\n    async onLoad() {\n      // 触底事件(要加载下一页的数据咯), 内部会自动把loading改为true\n      this.page++;\n      const res = await this.getListFn();\n\n      if (res.data.result.songs === undefined) {\n        // 没有更多数据了\n        this.finished = true; // 全部加载完成(list不会在触发onload方法)\n\n        this.loading = false; // 本次加载完成\n\n        return;\n      }\n\n      this.resultList = [...this.resultList, ...res.data.result.songs];\n      this.loading = false; // 数据加载完毕-保证下一次还能触发onload\n    }\n\n  },\n  components: {\n    SongItem\n  }\n};","map":{"version":3,"mappings":"AA+CA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACAA;IACA;MACAC,SADA;MACA;MACAC,UAFA;MAEA;MACAC,cAHA;MAGA;MACAC,cAJA;MAIA;MACAC,eALA;MAKA;MACAC,OANA;MAMA;MACAC,WAPA,CAOA;;IAPA;EASA,CAXA;;EAYA;IACA;IACAC;IACA;EACA,CAhBA;;EAiBAC;IACA;MACA;QACAC,oBADA;QAEAC,SAFA;QAGAC,4BAHA,CAGA;;MAHA,GADA,CAKA;MACA;MACA;MACA;MACA;IACA,CAXA;;IAYA;MACA;MACA,cAFA,CAEA;;MACA,sBAHA,CAGA;;MACA,iBAJA,CAIA;;MACA;MACAJ;MACA;MACA,qBARA,CAQA;IACA,CArBA;;IAsBA;MACA;MACA;MACA;MACA;MACA;MACA;QACA,cADA,CACA;;QACA,sBAFA,CAEA;QACA;;QACA;UACA;UACA;UACA;QACA;;QACA;QACAA,iBAVA,CAWA;;QACA;UACA;UACA;QACA;;QACA;QACA;MACA,CAlBA,EAkBA,GAlBA;IAmBA,CA/CA;;IAgDA;MACA;MACA;MACA;;MACA,IACAK,mCADA,EAEA;QAAA;QACA,qBADA,CACA;;QACA,qBAFA,CAEA;;QACA;MACA;;MACA;MACA,qBAZA,CAYA;IACA;;EA7DA,CAjBA;EAgFAC;IACAC;EADA;AAhFA","names":["data","value","hotArr","resultList","loading","finished","page","timer","console","methods","keywords","limit","offset","res","components","SongItem"],"sourceRoot":"src/views/Search","sources":["index.vue"],"sourcesContent":["<template>\r\n  <div>\r\n    <van-search\r\n      shape=\"round\"\r\n      v-model=\"value\"\r\n      placeholder=\"请输入搜索关键词\"\r\n      @input=\"inputFn\"\r\n    />\r\n    <!-- 搜索下容器 -->\r\n    <div class=\"search_wrap\" v-if=\"resultList.length === 0\">\r\n      <!-- 标题 -->\r\n      <p class=\"hot_title\">热门搜索</p>\r\n      <!-- 热搜关键词容器 -->\r\n      <div class=\"hot_name_wrap\">\r\n        <!-- 每个搜索关键词 -->\r\n        <span\r\n          class=\"hot_item\"\r\n          v-for=\"(obj, index) in hotArr\"\r\n          :key=\"index\"\r\n          @click=\"fn(obj.first)\"\r\n          >{{ obj.first }}</span\r\n        >\r\n      </div>\r\n    </div>\r\n    <!-- 搜索结果 -->\r\n    <div class=\"search_wrap\" v-else>\r\n      <!-- 标题 -->\r\n      <p class=\"hot_title\">最佳匹配</p>\r\n      <van-list\r\n        v-model=\"loading\"\r\n        :finished=\"finished\"\r\n        finished-text=\"没有更多了\"\r\n        @load=\"onLoad\"\r\n      >\r\n        <SongItem\r\n          v-for=\"obj in resultList\"\r\n          :key=\"obj.id\"\r\n          :name=\"obj.name\"\r\n          :author=\"obj.ar[0].name\"\r\n          :id=\"obj.id\"\r\n        ></SongItem>\r\n      </van-list>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n// 目标: 铺设热搜关键字\r\n// 1. 搜索框van-search组件, 关键词标签和样式\r\n// 2. 找接口, api/Search.js里定义获取搜索关键词的请求方法\r\n// 3. 引入到当前页面, 调用接口拿到数据循环铺设页面\r\n// 4. 点击关键词把值赋予给van-search的v-model变量\r\n\r\n// 目标: 铺设搜索结果\r\n// 1. 找到搜索结果的接口 - api/Search.js定义请求方法\r\n// 2. 再定义methods里getListFn方法(获取数据)\r\n// 3. 在点击事件方法里调用getListFn方法拿到搜索结果数据\r\n// 4. 铺设页面(首页van-cell标签复制过来)\r\n// 5. 把数据保存到data后, 循环van-cell使用即可(切换歌手字段)\r\n// 6. 互斥显示搜索结果和热搜关键词\r\n\r\n// 目标: 搜索框-显示结果\r\n// 1. @input给van-search绑定事件\r\n// 2. @input事件中, 获取搜索结果保存 resultList中\r\n// 3. 判断如果搜索关键字为空(.length === 0), 数组清空, 阻止网络请求执行(提前return)\r\n\r\n// 目标: 加载更多\r\n// 1. 集成list组件-定义相关的变量(搞懂变量的作用) -监测触底事件\r\n// 2. 一旦触底, 自动执行onload方法\r\n// 3. 对page++, 给后台传递offset偏移量参数-请求下一页的数据\r\n// 4. 把当前数据和下一页新来的数据拼接起来用在当前 页面的数组里\r\n// (切记) - 加载更多数据后,一定要把loading改成false, 保证下一次还能触发onload方法\r\nimport { hotSearchAPI, searchResultListAPI } from \"@/pi\";\r\nimport SongItem from \"@/components/SongItem\";\r\nexport default {\r\n  data() {\r\n    return {\r\n      value: \"\", // 搜索关键词\r\n      hotArr: [], // 热搜关键字\r\n      resultList: [], // 搜索结果\r\n      loading: false, // 加载中 (状态) - 只有为false, 才能触底后自动触发onload方法\r\n      finished: false, // 未加载全部 (如果设置为true, 底部就不会再次执行onload, 代表全部加载完成)\r\n      page: 1, // 当前搜索结果的页码\r\n      timer: null // 输入框-防抖定时器\r\n    };\r\n  },\r\n  async created() {\r\n    const res = await hotSearchAPI();\r\n    console.log(res);\r\n    this.hotArr = res.data.result.hots;\r\n  },\r\n  methods: {\r\n    async getListFn() {\r\n      return await searchResultListAPI({\r\n        keywords: this.value,\r\n        limit: 20,\r\n        offset: (this.page - 1) * 20, // 固定公式\r\n      }); // 把搜索结果return出去\r\n      // (难点):\r\n      // async修饰的函数 -> 默认返回一个全新Promise对象\r\n      // 这个Promise对象的结果就是async函数内return的值\r\n      // 拿到getListFn的返回值用await提取结果\r\n    },\r\n    async fn(val) {\r\n      // 点击热搜关键词\r\n      this.page = 1; // 点击重新获取第一页数据\r\n      this.finished = false; // 点击新关键词-可能有新的数据\r\n      this.value = val; // 选中的关键词显示到搜索框\r\n      const res = await this.getListFn();\r\n      console.log(res);\r\n      this.resultList = res.data.result.songs;\r\n      this.loading = false; // 本次数据加载完毕-才能让list加载更多\r\n    },\r\n    async inputFn() {\r\n      // 目标: 输入框改变-逻辑代码-慢点执行\r\n      // 解决: 防抖\r\n      // 概念: 计时n秒, 最后执行一次, 如果再次触发, 重新计时\r\n      // 效果: 用户在n秒内不触发这个事件了, 才会开始执行逻辑代码\r\n      if (this.timer) clearTimeout(this.timer)\r\n      this.timer = setTimeout(async () => {\r\n        this.page = 1; // 点击重新获取第一页数据\r\n        this.finished = false // 输入框关键字改变-可能有新数据(不一定加载完成了)\r\n        // 输入框值改变\r\n        if (this.value.length === 0) {\r\n          // 搜索关键词如果没有, 就把搜索结果清空阻止网络请求发送(提前return)\r\n          this.resultList = [];\r\n          return;\r\n        }\r\n        const res = await this.getListFn();\r\n        console.log(res);\r\n        // 如果搜索结果响应数据没有songs字段-无数据\r\n        if (res.data.result.songs === undefined) {\r\n          this.resultList = [];\r\n\t  return\r\n        }\r\n        this.resultList = res.data.result.songs;\r\n        this.loading = false;\r\n      }, 900)\r\n    },\r\n    async onLoad() {\r\n      // 触底事件(要加载下一页的数据咯), 内部会自动把loading改为true\r\n      this.page++;\r\n      const res = await this.getListFn();\r\n      if (\r\n        res.data.result.songs === undefined\r\n      ) { // 没有更多数据了\r\n        this.finished = true; // 全部加载完成(list不会在触发onload方法)\r\n        this.loading = false; // 本次加载完成\r\n        return;\r\n      }\r\n      this.resultList = [...this.resultList, ...res.data.result.songs];\r\n      this.loading = false; // 数据加载完毕-保证下一次还能触发onload\r\n    },\r\n  },\r\n  components: {\r\n    SongItem,\r\n  },\r\n};\r\n</script>\r\n\r\n<style scoped>\r\n/* 搜索容器的样式 */\r\n.search_wrap {\r\n  padding: 0.266667rem;\r\n}\r\n\r\n/*热门搜索文字标题样式 */\r\n.hot_title {\r\n  font-size: 0.32rem;\r\n  color: #666;\r\n}\r\n\r\n/* 热搜词_容器 */\r\n.hot_name_wrap {\r\n  margin: 0.266667rem 0;\r\n}\r\n\r\n/* 热搜词_样式 */\r\n.hot_item {\r\n  display: inline-block;\r\n  height: 0.853333rem;\r\n  margin-right: 0.213333rem;\r\n  margin-bottom: 0.213333rem;\r\n  padding: 0 0.373333rem;\r\n  font-size: 0.373333rem;\r\n  line-height: 0.853333rem;\r\n  color: #333;\r\n  border-color: #d3d4da;\r\n  border-radius: 0.853333rem;\r\n  border: 1px solid #d3d4da;\r\n}\r\n\r\n/* 给单元格设置底部边框 */\r\n.van-cell {\r\n  border-bottom: 1px solid lightgray;\r\n}\r\n</style>"]},"metadata":{},"sourceType":"module"}